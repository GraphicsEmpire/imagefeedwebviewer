<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ImageQ</title>

    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/Tween.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>

    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/colorbrewer.css">

    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/bootstrap.min.js"></script>
    <script type="text/javascript" src="js/colorbrewer.js"></script>

    <script type="text/javascript" src="js/reconnecting-websocket.min.js"></script>

    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>

</head>
<body>
    <div><span id="perf-mon"></span> </div>
    <div class="alert alert-danger"><span id="fpga_conn_status"></span> </div>

    <a href="" id="btnNext">next</a>
    <a href="" id="btnPrev">prev</a>

    <script>
        var scale_side_panel = 4.5;
        var scale_center_panel = 8.0;
        var ws_connect = false;
        var nx_sides = 10;
        var nx_panels = nx_sides * 2 + 1;
        var t_wait_area = 0.4;
        var stops = new Array(nx_panels);

        var anim_forward = false;

        var stats = new Stats();
        stats.showPanel(0); //0: fps
        //stats.showPanel(1); //1: ms
        //stats.showPanel(2); //2: mb
        //stats.showPanel(3); //3+: custom
        document.body.appendChild(stats.dom );


        //create stops
        for(var i=0; i < nx_panels; i++) {
            if(i < nx_sides) {
                stops[i] = (i / (nx_sides - 1)) * t_wait_area;
                stops[nx_panels - i - 1] = 1.0 - stops[i];
            }
            else if(i == nx_sides){
                stops[i] = 0.5;
            }
            //console.log("stop " + i + " = " + stops[i]);
        }


        console.log("Window dim [" + window.innerWidth + "x" + window.innerHeight + "]");

        //scene setup
        window.addEventListener('resize', onWindowResize, false);

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 60.0, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z  = 5;

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        var curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3( -2, 0, 2 ),
                new THREE.Vector3( -0.5, 0.5, 0 ),
                new THREE.Vector3( 0.5, 0.5, 0 ),
                new THREE.Vector3( 2, 0, 2 )
        );

        var geometry = new THREE.Geometry();
        geometry.vertices = curve.getPoints( 50 );

        var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

        // Create the final Object3d to add to the scene
        var curveObject = new THREE.Line( geometry, material );
        scene.add(curveObject);

        curve.getPointAt(0);
        //var composer = new THREE.EffectComposer(renderer);
        //add_frame('textures/bus.jpg');

        var quat_side_panel = new THREE.Quaternion();
        quat_side_panel.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 5 );

        var quat_center_panel = new THREE.Quaternion();
        quat_center_panel.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), 0.0 );

        var panels = new THREE.Object3D();

        for(var i=0; i < nx_panels; i++) {
            var pt = curve.getPointAt(stops[i]);
            var tangent = curve.getTangentAt(stops[i]).normalize();
            var axis = new THREE.Vector3();
            var up = undefined;

            if(i <= nx_sides)
                up = new THREE.Vector3(0, 0, -1);
            else
                up = new THREE.Vector3(0, 0, 1);

            axis.crossVectors(up, tangent).normalize();
            if(axis.length() < 0.01) {
                console.log("AXIS is degenerate! i = " + i);
            }

            //amount of rotation needed
            var radians = Math.acos( up.dot(tangent) );
            quat_side_panel.setFromAxisAngle( axis, radians);


            var panel = undefined;

            //current view
            if(i < nx_sides || i > nx_sides) {
                panel = create_panel_colored(pt, scale_side_panel, quat_side_panel);
            }
            else if(i == nx_sides) {
                panel = create_panel_colored(pt, scale_center_panel, quat_center_panel);
            }

            panels.add(panel);
        }

        scene.add(panels);


        function create_panel_colored(pos, scale, quat) {
            var geometry = new THREE.PlaneGeometry(0.1, 0.1, 1);
            geometry.computeFaceNormals();

            var mtrl = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, side: THREE.DoubleSide });
            var panel = new THREE.Mesh(geometry, mtrl);
            panel.position.x = pos.x;
            panel.position.y = pos.y;
            panel.position.z = pos.z;
            panel.scale.x += scale;
            panel.scale.y += scale;
            panel.setRotationFromQuaternion(quat);

            return panel;
        }

        //create panel
        function create_panel_textured(pos, scale, quat, frame_uri) {
            var geometry = new THREE.PlaneGeometry(0.1, 0.1, 1);
            geometry.computeFaceNormals();

            var mtrl = undefined;
            if(frame_uri == undefined)
                mtrl = new THREE.MeshBasicMaterial( { color: 0xFFFFFF, side: THREE.DoubleSide });
            else {
                var texloader = new THREE.TextureLoader();
                texloader.crossOrigin = '';


                // load a resource
                texloader.load(
                        // resource URL
                        frame_uri,
                        // Function when resource is loaded
                        function (texture) {
                            texture.generateMipmaps = false;
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            texture.wrapS = THREE.ClampToEdgeWrapping;
                            texture.wrapT = THREE.ClampToEdgeWrapping;

                            mtrl = new THREE.MeshBasicMaterial({map: texture, overdraw: true});
                        },
                        // Function called when download progresses
                        function (xhr) {
                            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                        },
                        // Function called when download errors
                        function (xhr) {
                            console.log('An error happened');
                        }
                );


            }

            //var mtrl = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, side: 2, shading: THREE.SmoothShading } );
            var panel = new THREE.Mesh(geometry, mtrl);
            panel.position.x = pos.x;
            panel.position.y = pos.y;
            panel.position.z = pos.z;
            panel.scale.x += scale;
            panel.scale.y += scale;
            panel.setRotationFromQuaternion(quat);

            return panel;
        }

        //remove last panel
        function remove_last() {
            if(scene.children.length == 0)
                return;

            //remove last child
            console.log("scene# " + scene.children.length + " ,panels#" + panels.children.length);
            var sel_obj = panels.children[panels.children.length - 1];
            if(sel_obj)
                panels.remove(sel_obj);
        }

        function load_frame_as_texture(frame_uri) {
            var texloader = new THREE.TextureLoader();
            texloader.crossOrigin = '';

            var output_texture = undefined;

            // load a resource
            texloader.load(
                    // resource URL
                    frame_uri,
                    // Function when resource is loaded
                    function (texture) {
                        texture.generateMipmaps = false;
                        texture.minFilter = THREE.LinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        texture.wrapS = THREE.ClampToEdgeWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;

                        return texture;
                    },
                    // Function called when download progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                    // Function called when download errors
                    function (xhr) {
                        console.log('An error happened');
                    }
            );

            return undefined;
        }


        function handle_new_frame(frame_uri) {
            TWEEN.removeAll();
            var handled_on_transition_completed = false;

            //var timeline = createjs.Timeline();
            for(var i=0; i < panels.children.length-1; i++) {
                var panel = panels.children[i];

                //orientation
//                var q1 = panel.quaternion;
//                var qm = new THREE.Quaternion();
//                var q2 = quat_side_panel;
//                if(i == nx_sides - 1)
//                    q2 = quat_center_panel;

                //position
//                var p1 = panel.position;
//                var p2 = curve.getPointAt(stops[i + 1]);

                var o = {t: 0};
                var rad90 = Math.PI * .5;
                //new TWEEN.Tween( panel.rotation ).to( { z:  panel.rotation.z + rad90}, 1000 ).start();
                // rotation (using slerp)


                //orientation
                var qm = new THREE.Quaternion();
                var q1 = panel.quaternion;
                var q2 = quat_side_panel;

                var pm = new THREE.Vector3();
                var p1 = panel.position;
                var p2 = curve.getPointAt(stops[i + 1]);

                if(i == nx_sides - 1)
                    q2 = quat_center_panel;

                var o = {t : 0};
                var tw1 = new TWEEN.Tween(panel.position);
                tw1.to({ x: p2.x, y: p2.y, z: p2.z }, 60);
                tw1.onComplete(handleComplete);
                tw1.start();

                //on complete
                function handleComplete() {
                    //Tween complete
                    console.log("finished moving panel " + i);

                    if((i == panels.children.length - 1) && !handled_on_transition_completed) {

                        handled_on_transition_completed = true;

                        console.log("remove last panel and add new panel");
                        //remove last
                        remove_last();

                        if(frame_uri == undefined)
                            return false;

                        //load new frame
                        //var texture = load_frame_as_texture(frame_uri);
                        //var first = create_panel_textured(curve.getPointAt(stops[0]), scale_side_panel, quat_side_panel, frame_uri);

                        var texloader = new THREE.TextureLoader();
                        texloader.crossOrigin = '';

                        // load a resource
                        texloader.load(
                                // resource URL
                                frame_uri,
                                // Function when resource is loaded
                                function (texture) {
                                    texture.generateMipmaps = false;
                                    texture.minFilter = THREE.LinearFilter;
                                    texture.magFilter = THREE.LinearFilter;
                                    texture.wrapS = THREE.ClampToEdgeWrapping;
                                    texture.wrapT = THREE.ClampToEdgeWrapping;
                                    var mtrl = new THREE.MeshBasicMaterial({map: texture, overdraw: true});

                                    var geometry = new THREE.PlaneGeometry(0.1, 0.1, 1);
                                    geometry.computeFaceNormals();

                                    //pos
                                    var pos = curve.getPointAt(stops[0]);

                                    //panel
                                    var panel = new THREE.Mesh(geometry, mtrl);
                                    panel.position.x = pos.x;
                                    panel.position.y = pos.y;
                                    panel.position.z = pos.z;
                                    panel.scale.x += scale_side_panel;
                                    panel.scale.y += scale_side_panel;
                                    panel.setRotationFromQuaternion(quat_side_panel);

                                    panels.children.splice(0, 0, panel);

                                },
                                // Function called when download progresses
                                function (xhr) {
                                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                                },
                                // Function called when download errors
                                function (xhr) {
                                    console.log('An error happened');
                                }
                        );


                    }

                }

            }
        }

        //add a new panel with image to the queue
        $("#btnNext").click(function() {
            handle_new_frame("textures/bus.jpg");
            return false;
        });


        function toHHMMSS(sec) {
            var sec_num = parseInt(sec, 10); // don't forget the second param
            var hours   = Math.floor(sec_num / 3600);
            var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
            var seconds = sec_num - (hours * 3600) - (minutes * 60);
            if (hours   < 10) {hours   = "0"+hours;}
            if (minutes < 10) {minutes = "0"+minutes;}
            if (seconds < 10) {seconds = "0"+seconds;}
            var time    = hours+':'+minutes+':'+seconds;
            return time;
        }

        // @return {integer} a random int between min and max
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min) + min);
        }

        //fpga websocket handler
        $(function() {
            var ws_fpga = new ReconnectingWebSocket("ws://xsjaaronn50:9999");
            ws_fpga.onmessage = function(evt) {

                if(!ws_connect)
                    return;

                var d = $.parseJSON(evt.data);

                if (!d.data.images)
                    return;

                if (d.data.labels) {
                    console.log("labels: " + d.data.labels);
                }

                if( d.data.images && d.data.labels) {
                    console.log("current image: " + d.data.images[0]);
                    //now adding frames work
                    handle_new_frame(d.data.images[0]);
                }
            }
            ws_fpga.onopen = function(evt) {
                $('#fpga_conn_status').html('<b>Connected to Xilinx Virtex UltraScale FPGA</b>');
            }
            ws_fpga.onerror = function(evt) {
                $('#fpga_conn_status').html('<b>Error in connecting to native app</b>');
            }
            ws_fpga.onclose = function(evt) {
                $('#fpga_conn_status').html('<b>Closed connection</b>');
            }
        });

        // shim layer with setTimeout fallback
        window.requestAnimFrame = (function(){
            return  window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    function(callback) {
                        window.setTimeout(callback, 1000 / 60);
                    };
        })();

        function animate() {
            render();

            requestAnimFrame(animate);

            stats.update();

            TWEEN.update();

        }

        function render() {
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            console.log("I sensed the window is resized!");
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        animate();
    </script>

</body>
</html>